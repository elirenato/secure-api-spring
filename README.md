# Secure API Quarkus

This project is a Java REST API application that was configured to use [Keycloak](https://www.keycloak.org) as access management.

It was bootstrapped using [Spring Initializer](https://start.spring.io/) with the following dependencies:
- RESTful classic (spring-boot-starter-web).
- JUnit Jupiter, Hamcrest and Mockito (spring-boot-starter-test).
- OIDC to enable the integration with Keycloak (spring-boot-starter-oauth2-resource-server).
- Jacoco to generate the coverage test report.
x Hibernate ORM Panache and Hibernate Validator.
x Liquibase (With PostgreSQL as the database).
x [TestContainers](https://www.testcontainers.org/) to run tests in an isolated PostgresSQL database.
x Container Image Jib to build the image that will be pulled by Kubernetes.
x Kubernetes, to generate the resources needed to deploy on Kubernetes.
- [Java Faker](http://github.com/DiUS/java-faker) to generate test data.
- [Lombok](https://projectlombok.org/) to keep the code clean.

## Directory Structure

This project follows the default Java structure `/src/main`.

- `/src/main/java` - The Java code.
- `/src/main/test` - The Java test code.
- `/src/main/docker` - The Docker files that were generated by Quarkus can be used to deploy the application depending on how you build the application (JVM, jar, or Native with GraalVM).
- `/src/main/docker/keycloak`: The Docker files to build the Keycloak Docker image required for this project.
- `/src/main/jenkins` - Jenkins file and resources that are used to set up the pipeline to build and deploy the application.
- `/src/main/postman` - Postman collection to be imported for test purposes.

## Running tests

By default, the tests use the Testcontainers to start a PostgreSQL container, so, you can just run:

`./mvnw test`

It's possible to run the tests without Testcontainers using the command:

`./mvnw test -Dtest.containers.disabled`

But you must have a PostgresSQL container running and the `app_test` database already created.

See the `src/test/resource/application.properties` to see the credentials used by the tests.

## Before run the application in dev mode

### Keycloak (20.0.1) and PostgreSQL (15.1)

This application depend on these services, so, you must have them running.

For dev purpose, you can use the bash script `./start-keycloak.sh` to start Docker containers with these services.

The Keycloak will be available at `http://localhost:8080`.

To stop the containers you can use the script `./stop-keycloak.sh`.

### Keycloak Realm

To complete the setup of Keycloak, you also need to configure a Realm to test the application.

[Configure a new realm](./docs/create-new-realm-keycloak-18.pdf).

Double-check the following properties of the `src/main/resource/application.properties` file.
The values of them must match with the values used to create the test realm.

```
auth-server-url=${QUARKUS_OIDC_AUTH-SERVER-URL:http://localhost:8080/realms/app}
quarkus.oidc.client-id=${QUARKUS_OIDC_CLIENT-ID:secure-api}
quarkus.oidc.credentials.secret=${QUARKUS_OIDC_CREDENTIALS_SECRET:change_me}
```

### Run the application in dev mode

Finally, it's possible to run the application:
```bash
./mvnw compile quarkus:dev
```

PS: Quarkus ships with a Dev UI, which is available in dev mode only at http://localhost:8080/q/dev/.

## Packaging and running the application

The application can be packaged using:
```bash
./mvnw package
```

## Deploying application to Kubernetes

The application is deployed to Kubernetes using Jenkins:

1. The first stage, run the tests with coverage report.
2. The second stage, package the application, build an image and push the image to a private Docker Registry repository.
3. The last stage, uses the Kubernetes resources generated by Quarkus to deploy the application.

See the [Jenkinsfile](./src/main/jenkins/Jenkinsfile) for more details:

PS: The Jenkins agent to build this project is Docker. The image created for Jenkins agent, uses a GraalVM JDK,
as I intend to do some tests building a native executable in the future.

## Creating a native executable

**PS: NOT TESTED YET**

You can create a native executable using:
```shell script
./mvnw package -Pnative
```

Or, if you don't have GraalVM installed, you can run the native executable build in a container using:
```shell script
./mvnw package -Pnative -Dquarkus.native.container-build=true
```

You can then execute your native executable with: `./target/secure-api-quarkus-1.0.0-SNAPSHOT-runner`

If you want to learn more about building native executables, please consult https://quarkus.io/guides/maven-tooling.
